#' Modifications to Adaptive Synthetic Sampling (ADASYN) for Imbalanced Data
#'
#' Improved Adaptive Synthetic Sampling (ADASYN) for balancing class distributions
#' in imbalanced datasets. It can optionally select informative features based
#' on correlation with the response variable and includes two optional tuning
#' parameters: corrupt and diminish. Corrupt will simulate addition of random noise
#' and diminish will reduce the feature space to eliminate junk variables.
#'
#' @param df A data frame containing the dataset.
#' @param var A character string specifying the name of the binary response variable in the data frame.
#' @param k An integer specifying the number of nearest neighbors to consider for the ADASYN algorithm. Default is 5.
#' @param over_ratio A numeric value for the oversampling ratio (the factor by which the minority class is oversampled). Default is 1.
#' @param num_features An integer specifying the number of features to consider. Defaults to all columns except the response variable.
#' @param subsetFeat A logical indicating whether to select the most informative features based on correlation with the response variable. Default is `FALSE`.
#' @param completeData A logical indicating whether to use the entire dataset (TRUE) or a subset of selected features (FALSE). Default is `FALSE`.
#' @param corrupt A numeric value specifying the percentage of data corruption to apply (e.g., random noise). Default is `NULL` (no corruption).
#' @param diminish A numeric value between 0 and 1 that controls the proportion features included based on correlation with the response variable. Default is 0.5.
#'
#' @return A data frame of synthetic samples generated by the ADASYN algorithm to balance the class distribution.
#'
#' @details
#' The function first optionally selects a subset of features based on their correlation with the response variable (`var`). Then, the ADASYN algorithm is applied to create synthetic samples of the minority class. The oversampling ratio and number of nearest neighbors are parameters for the ADASYN process. Data corruption and feature selection are optional steps to enhance the generalizability of the model.
#'
#' @export
tjadasyn <- function(df, var, k = 5, over_ratio = 1, num_features= dim(df)[2]-1, subsetFeat = FALSE, completeData = FALSE, corrupt = NULL, diminish = 0.5) {
  cd <- NULL
  resp <- df[[var]]
  if(subsetFeat){
    ### Select most informative features
    corrMat <- cor(df)
    # find column index of response variable
    i <- which(colnames(df) == var)
    corrCut <- quantile(abs(corrMat[,i]), probs = diminish)
    if(completeData){cd <- df}
    ## Pull features above Cutcorr
    df <- df[,which(corrMat[,i]>= corrCut)]
    ifelse(var %in% colnames(df),"reponse in colnames","response not in colnames")
  }
  final <- adasyn_impl(df, var, k, over_ratio, cd, corrupt = corrupt)
}

adasyn_impl <- function(df, var, k = 5, over_ratio = 1, cd = cd, call = caller_env(), corrupt) {
  majority_count <- max(table(df[[var]]))
  ratio_target <- majority_count * over_ratio
  which_upsample <- which(table(df[[var]]) < ratio_target)
  samples_needed <- ratio_target - table(df[[var]])[which_upsample]
  min_names <- names(samples_needed) # minority class
  out_dfs <- list()

  data_mat <- as.matrix(df[names(df) != var])
  # k nearest neighbors
  ids_full <- RANN::nn2(data_mat, k = k + 1, searchtype = "priority")$nn.idx
  if(!is.null(cd)){
    df <- cd
    data_mat <- as.matrix(df[names(df) != var])
  }
  for (i in seq_along(min_names)) { # minority class(es)
    min_class_in <- df[[var]] != min_names[i] # T/F is this index in the majority?

    r_value <- pmax(
      0,
      rowSums(matrix((min_class_in)[ids_full], ncol = ncol(ids_full))) - 1
    ) # proportion of majority class neighbors
    r_value <- r_value[!min_class_in]
    danger_ids <- sample(seq_along(r_value), samples_needed[i], TRUE,
                         prob = r_value
    ) # sampling from minority class with weight for difficulty to learn

    minority <- data_mat[!min_class_in, , drop = FALSE] # minority observations w/o response

    if (nrow(minority) <= k) {
      cli::cli_abort("Not enough observations of {.val {min_names[i]}} to perform ADASYN.", call = call)
    }

    tmp_df <- as.data.frame(
      adasyn_sampler(
        minority, k, samples_needed[i],
        danger_ids
      )
    )

    colnames(tmp_df) <- colnames(data_mat)
    tmp_df[[var]] <- min_names[i] #assign minority class for new data points
    out_dfs[[i]] <- tmp_df
  }
  final <- rbind(df, do.call(rbind, out_dfs))
  final[[var]] <- factor(final[[var]], levels = levels(df[[var]]))
  rownames(final) <- NULL
  # Add responses
  j <- which(colnames(final)==var)
  final <- final[,-j]
  # find minority and majority class value
  tb <- table(df[[var]])
  if(tb[1]<tb[2]){
    #tb[1] is minority class
    minority <- as.numeric(names(tb[1]))
    maj <- as.numeric(names(tb[2]))
  }else{
    #tb[2] is the majority
    minority <- as.numeric(names(tb[2]))
    maj <- as.numeric(names(tb[1]))
  }
  # assign all new samples minority class value
  if(is.null(corrupt)){
    final[,j] <- c(df[[var]],rep(minority,(dim(final)[1]-dim(df)[1])))
  }else{
    final[,j] <- c(df[[var]],rep(minority,(dim(final)[1]-dim(df)[1])))
    # flip labels proportionate to corruption parameter
    synth_ids <- dim(df)[1]+1:dim(final)[1]
    co <- sample(synth_ids, size = length(synth_ids)*corrupt)
    final[co,j] <- maj
  }

  final
}

adasyn_sampler <- function(data, k, n_samples, smote_ids) {
  # data is minority observations
  # smote_ids is sampled from minority class weighted by diff to learn
  ids <- RANN::nn2(data, k = k + 1, searchtype = "priority")$nn.idx #list of nearest neighbors for minority
  index_len <- tabulate(smote_ids, NROW(data)) # how many times did each obs get sampled
  out <- matrix(0, nrow = n_samples, ncol = ncol(data))
  sampleids <- sample.int(k, n_samples, TRUE)
  runif_ids <- stats::runif(n_samples)

  iii <- 0
  for (row_num in which(index_len != 0)) {
    index_selection <- iii + seq_len(index_len[row_num])
    # removes itself as nearest neighbour
    id_knn <- ids[row_num, ids[row_num, ] != row_num]
    dif <- data[id_knn[sampleids[index_selection]], ] -
      data[rep(row_num, index_len[row_num]), ]
    gap <- dif * runif_ids[index_selection]
    out[index_selection, ] <- data[rep(row_num, index_len[row_num]), ] + gap
    iii <- iii + index_len[row_num]
  }

  out
}
